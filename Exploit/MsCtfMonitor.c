#include <windows.h>
#include <stdio.h>
#include <winternl.h>
#include <dbghelp.h>

// Define the function pointer type for Ndr64AsyncClientCall
typedef void (WINAPI *Ndr64AsyncClientCall_t)();

// Original function pointer
Ndr64AsyncClientCall_t Original_Ndr64AsyncClientCall = NULL;

// Hook function
void WINAPI Hooked_Ndr64AsyncClientCall() {
    printf("[+] Hooked Ndr64AsyncClientCall called!\n");
    // Call the original function if necessary
    if (Original_Ndr64AsyncClientCall) {
        Original_Ndr64AsyncClientCall();
    }
}

// Function to find the IAT entry in the main module
void* find_iat_entry_main(const char* functionName) {
    HMODULE hModule = GetModuleHandleA(NULL); // Get handle to the main module (ctfmon.exe)
    if (!hModule) {
        printf("Main module not loaded.\n");
        return NULL;
    }

    ULONG size;
    PIMAGE_IMPORT_DESCRIPTOR importDesc = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(
        hModule, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &size);
    if (!importDesc) {
        printf("No import directory found in main module.\n");
        return NULL;
    }

    while (importDesc->Name) {
        const char* importModule = (const char*)((BYTE*)hModule + importDesc->Name);
        if (_stricmp(importModule, "rpcrt4.dll") == 0) { // Target DLL
            PIMAGE_THUNK_DATA thunk = (PIMAGE_THUNK_DATA)((BYTE*)hModule + importDesc->FirstThunk);
            while (thunk->u1.Function) {
                FARPROC* func = (FARPROC*)&thunk->u1.Function;
                FARPROC targetFunc = GetProcAddress(GetModuleHandleA("rpcrt4.dll"), functionName);
                if (*func == targetFunc) {
                    return func;
                }
                thunk++;
            }
        }
        importDesc++;
    }
    return NULL;
}

// Function to replace placeholders in the trampoline
int replace_trampoline_value(char *shellcode, unsigned int size, unsigned __int64 original_value, unsigned __int64 value) {
    for (unsigned int pos = 0; pos < (size - sizeof(unsigned __int64)); pos += sizeof(unsigned __int64)) {
        if (*(unsigned __int64*)(shellcode + pos) == original_value) {
            *(unsigned __int64*)(shellcode + pos) = value;
            return 1; // Success
        }
    }
    return 0; // Failure
}

// Function to hook the IAT
BOOL HookIAT(const char* functionName, void* hookFunction) {
    void** IAT_entry = (void**)find_iat_entry_main(functionName);
    if (!IAT_entry) {
        printf("[-] Failed to locate IAT entry for %s.\n", functionName);
        return FALSE;
    }

    // Replace the IAT entry with the hook function
    DWORD oldProtect;
    if (VirtualProtect(IAT_entry, sizeof(void*), PAGE_READWRITE, &oldProtect)) {
        Original_Ndr64AsyncClientCall = (Ndr64AsyncClientCall_t)(*IAT_entry);
        *IAT_entry = hookFunction;
        VirtualProtect(IAT_entry, sizeof(void*), oldProtect, &oldProtect);
        printf("[+] IAT entry for %s hooked successfully.\n", functionName);
        return TRUE;
    } else {
        printf("[-] VirtualProtect failed: %lu\n", GetLastError());
        return FALSE;
    }
}

// Function to perform the hook
void PerformHook() {
    if (HookIAT("Ndr64AsyncClientCall", Hooked_Ndr64AsyncClientCall)) {
        printf("[+] Hook installed successfully.\n");
    } else {
        printf("[-] Failed to install hook.\n");
    }
}

// Entry point for the DLL
BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
        PerformHook();
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
